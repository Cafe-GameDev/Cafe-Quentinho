**PLANO DE DESENVOLVIMENTO: Refatoração e Extensão do Projeto "BodyLess"**

Este documento detalha o plano de desenvolvimento para o projeto "BodyLess", abrangendo a refatoração do sistema de configurações, a implementação de feedback de UI, a robusta internacionalização (I18N/L10N), e a adição de novas funcionalidades de jogo. O plano é dividido em três fases principais, com um total de 34 passos.

--- 
**Fase 1: Internacionalização e Refatoração do Sistema de Configurações (11 Passos)**

**Passo 1: Implementação Completa de Internacionalização (I18N/L10N)**
*   **Ação:**
    1.  **Atualizar `SettingsManager` (`BodyLess\Autoloads\settings_manager.gd`):**
        *   Modificar `DEFAULT_SETTINGS` para incluir um locale padrão (`OS.get_locale()`).
        *   Modificar `SETTINGS_TEMPLATE` para incluir **TODOS** os códigos de localidade válidos: `en_US`, `en_GB`, `en_IN`, `pt_BR`, `pt_PT`, `es_ES`, `es_LA`, `fr`, `de`, `it`, `nl`, `ja`, `ko`, `ru`, `zh_Hans`, `zh_Hant`, `sw`, `af`, `pl`, `tr`, `ar`, `fa`, `he`, `hi`, `ur`, `bn`, `id`, `vi`, `fil`, `th`, `ms`.
        *   **Implementar Lógica de Middleware/Fallback de Locale:** Na função `_validate_and_merge_settings`, ajustar a lógica para mapear o locale do sistema operacional e as variações:
            *   Inglês: Se `OS.get_locale()` começar com "en" e não for `en_US` ou `en_GB`, mapear para `en_US`.
            *   Espanhol: Se `OS.get_locale()` começar com "es" e não for `es_ES`, mapear para `es_LA`.
            *   Português: Se `OS.get_locale()` começar com "pt" e não for `pt_BR`, mapear para `pt_PT`.
            *   Chinês: Se `OS.get_locale()` for `zh_CN`, mapear para `zh_Hans`. Se for `zh_TW` ou `zh_HK`, mapear para `zh_Hant`. Se for `zh` genérico, mapear para `zh_Hans`.
            *   Garantir que `TranslationServer.set_locale(final_locale_code)` seja chamado após a validação e aplicação.
    2.  **Atualizar `language_options.gd` (`BodyLess\Scripts\UI\Settings\Locate\language_options.gd`):**
        *   Atualizar o dicionário `LOCALE_NAMES` com os nomes de exibição amigáveis para **TODOS** os códigos de localidade.
        *   Implementar a função `_populate_language_options()` para criar dinamicamente os botões de idioma, usando `tr("UI_LANGUAGE_...")` para o texto do botão e `set_meta("locale", locale_code)`.
        *   Garantir que os botões emitam `GlobalEvents.locale_setting_changed(locale_code)`.
        *   A função `_on_locale_setting_changed` deve desabilitar o botão do idioma atualmente selecionado.
    3.  **Criar/Atualizar Arquivos `.po`:**
        *   **Renomear `zh.po` para `zh_Hans.po`**.
        *   Criar os seguintes novos arquivos `.po` vazios em `BodyLess\I18N\`: `en_IN.po`, `zh_Hant.po`, `sw.po`, `af.po`, `pl.po`, `tr.po`, `ar.po`, `fa.po`, `he.po`, `hi.po`, `ur.po`, `bn.po`, `id.po`, `vi.po`, `fil.po`, `th.po`, `ms.po`.
        *   **Traduzir e Localizar Chaves:** Para **TODOS** os arquivos `.po` (existentes e novos), garantir que todas as `msgid`s presentes nos arquivos `en.po` e `pt_BR.po` (que contêm as chaves atuais) sejam copiadas e que as `msgstr`s sejam preenchidas com traduções **localizadas** (não apenas literais), incluindo as novas chaves `UI_LANGUAGE_` para os nomes dos idiomas.
    4.  **Atualizar `project.godot`:**
        *   Adicionar **TODOS** os arquivos `.po` (existentes e novos) à seção `localization/translations`.
        *   Remover as entradas antigas para `en.po`, `es.po` e `zh.po`.
*   **Justificativa:** Estabelecer um sistema de internacionalização robusto e flexível desde o início, permitindo a expansão para novos idiomas e a correta detecção/fallback de locales.

**Passo 2: Modificação do `GlobalEvents`**
*   **Ação:** Modificar `BodyLess\Autoloads\EventBus\global_events.gd`.
    1.  Remover todas as declarações de sinais individuais de áudio e vídeo (ex: `master_volume_changed`, `monitor_changed`, `gamma_correction_changed`, etc.).
    2.  Manter os novos sinais unificados: `setting_changed`, `loading_settings_changed`, `request_setting_changed`, `request_loading_settings_changed`.
*   **Justificativa:** Limpar o EventBus de sinais obsoletos.

**Passo 3: Remoção do `VideoManager`**
*   **Ação:**
    1.  Remover a entrada do `VideoManager` da lista de Autoloads em `BodyLess\project.godot`.
    2.  Excluir o arquivo `BodyLess\Autoloads\video_manager.gd`.
    3.  Excluir o arquivo `BodyLess\Autoloads\video_manager.gd.uid`.
*   **Justificativa:** Transferência de responsabilidades para o `SceneControl`.

**Passo 4: Adaptação dos Componentes da UI (Áudio e Vídeo)**
*   **Ação:** Para todos os scripts de UI de configurações (ex: `Scripts\UI\Settings\Audio\master.gd`, `music.gd`, `sfx.gd`, e todos os scripts em `Scripts\UI\Settings\Video\`).
    1.  **Verificação:** Confirmar que todos já estão emitindo o sinal `GlobalEvents.setting_changed` com o dicionário de dados correto.
    2.  **Limpeza:** Remover quaisquer funções `_ready()` que ainda contenham conexões a sinais antigos individuais.
*   **Justificativa:** Garantir que a UI emita apenas sinais unificados.

**Passo 5: Adaptação do `SettingsManager` (Conexões e Emissões)**
*   **Ação:** Modificar `BodyLess\Autoloads\settings_manager.gd`.
    1.  **Conexões:** Garantir que `_connect_signals()` esteja conectado apenas a `GlobalEvents.setting_changed`, `GlobalEvents.locale_setting_changed`, `GlobalEvents.load_settings_requested`, `GlobalEvents.save_settings_requested`, `GlobalEvents.close_settings_requested`, e `GlobalEvents.request_loading_settings_changed`. Remover quaisquer conexões a sinais de áudio/vídeo individuais antigos.
    2.  **Atualização de `live_settings`:** A função `_update_live_settings_from_change_data(change_data: Dictionary)` deve estar corretamente implementada para fundir o `change_data` no `live_settings`.
    3.  **Emissão de `loading_settings_changed`:** Confirmar que `load_settings()` emite `GlobalEvents.loading_settings_changed.emit(live_settings)` após carregar e validar as configurações.
*   **Justificativa:** O `SettingsManager` deve reagir ao sinal unificado de mudança e emitir o estado completo quando carregado.

**Passo 6: Adaptação do `AudioManager`**
*   **Ação:** Modificar `BodyLess\Autoloads\audio_manager.gd`.
    1.  **Conexões:** Em `_ready()`, garantir que esteja conectado a `GlobalEvents.play_sfx_by_key_requested`, `GlobalEvents.music_change_requested`, `GlobalEvents.setting_changed`, e `GlobalEvents.loading_settings_changed`. Remover quaisquer conexões a sinais de áudio individuais antigos.
    2.  **Handler `_on_setting_changed`:** Implementar/ajustar esta função para verificar a chave "audio" no `change_data` e chamar `call_deferred("_update_bus_volume", bus_name, value)` para `master_volume`, `music_volume`, e `sfx_volume`.
    3.  **Handler `_on_loading_settings_changed`:** Implementar/ajustar esta função para aplicar as configurações de áudio iniciais (master, music, sfx) ao `AudioServer` quando as configurações são carregadas.
    4.  **Requisição Inicial:** Garantir que `GlobalEvents.request_loading_settings_changed.emit()` seja chamado no `_ready()` para que o `SettingsManager` carregue e emita as configurações iniciais.
*   **Justificativa:** O `AudioManager` deve reagir aos sinais unificados para aplicar as configurações de áudio.

**Passo 7: Modificação da Cena `SceneControl.tscn`**
*   **Ação:** Abrir `BodyLess\Scenes\scene_control.tscn` no editor Godot.
    1.  Adicionar um nó `CanvasModulate` como filho direto do `SceneControl`. Este nó será usado para aplicar `gamma_correction`, `contrast` e `brightness`.
    2.  (Opcional, para efeitos mais avançados como Colorblind): Adicionar um `ColorRect` que cubra toda a tela (ancoras `Full Rect`) como filho do `CanvasLayer`, e anexar um `ShaderMaterial` a ele.
*   **Justificativa:** Fornecer os nós visuais necessários para o `SceneControl` manipular as configurações de vídeo que afetam a renderização.

**Passo 8: Adaptação do `SceneControl` para Gerenciamento de Vídeo e Idioma**
*   **Ação:** Modificar `BodyLess\Scripts\scene_control.gd`.
    1.  **`@onready` para `CanvasModulate`:** Adicionar `@onready var canvas_modulate: CanvasModulate = $CanvasModulate` (assumindo o nome do nó).
    2.  **Conexões:** Em `_ready()`, adicionar:
        *   `GlobalEvents.loading_settings_changed.connect(_on_loading_settings_changed)`
        *   `GlobalEvents.setting_changed.connect(func(change_data: Dictionary): _on_setting_changed(change_data))`
        *   `GlobalEvents.locale_setting_changed.connect(func(locale_code): TranslationServer.set_locale(locale_code))` para que o `SceneControl` aplique a mudança de idioma.
    3.  **Handler `_on_loading_settings_changed(settings: Dictionary)`:**
        *   Esta função será chamada quando as configurações iniciais forem carregadas.
        *   Ela deve iterar sobre `settings.video` e chamar funções auxiliares para aplicar cada configuração.
        *   Chamar `TranslationServer.set_locale(settings.language.locale)` para aplicar o idioma inicial.
    4.  **Handler `_on_setting_changed(change_data: Dictionary)`:**
        *   Esta função será chamada quando uma configuração específica for alterada.
        *   Se `change_data` contiver a chave "video", iterar sobre `change_data.video` e chamar `call_deferred` para as funções auxiliares correspondentes.
    5.  **Implementar Funções Auxiliares para Aplicação de Vídeo:**
        *   `_apply_monitor_index(monitor_index: int)`: Usa `DisplayServer.window_set_current_screen()` ou `DisplayServer.window_set_position()`.
        *   `_apply_window_mode(new_mode: int)`: Usa `DisplayServer.window_set_mode()`.
        *   `_apply_resolution(new_resolution: Vector2i)`: Usa `DisplayServer.window_set_size()` (para modo janela) e/ou ajusta o `game_viewport.size`.
        *   `_apply_aspect_ratio(aspect_ratio_index: int)`: Ajusta `ProjectSettings.set_setting("display/window/stretch/aspect", value)`.
        *   `_apply_dynamic_render_scale_mode(mode: int)`: Ajusta `ProjectSettings.set_setting("rendering/scaling_3d/mode", value)` para FSR ou outros modos de escala.
        *   `_apply_render_scale(scale_value: float)`: Ajusta `ProjectSettings.set_setting("rendering/scaling_3d/scale", value)`.
        *   `_apply_frame_rate_limit_mode(mode: int)`: Ajusta `Engine.max_fps` ou `DisplayServer.window_set_vsync_mode()`.
        *   `_apply_max_frame_rate(fps_value: int)`: Usa `Engine.max_fps`.
        *   `_apply_vsync_mode(mode: int)`: Usa `DisplayServer.window_set_vsync_mode()`.
        *   `_apply_gamma_correction(gamma_value: float)`: Ajusta `canvas_modulate.color.v` (para valor) ou um shader.
        *   `_apply_contrast(contrast_value: float)`: Ajusta `canvas_modulate.color` ou um shader.
        *   `_apply_brightness(brightness_value: float)`: Ajusta `canvas_modulate.color` ou um shader.
        *   `_apply_shaders_quality(quality_level: int)`: Pode usar `ProjectSettings.set_setting("rendering/quality/shader_quality", value)`.
        *   `_apply_effects_quality(quality_level: int)`: Pode usar `ProjectSettings.set_setting("rendering/quality/texture_filter", value)` ou similar.
        *   `_apply_colorblind_mode(mode: int)`: Ativa/desativa um shader de correção de daltonismo.
        *   `_apply_reduce_screen_shake(enabled: bool)`: Define uma flag global ou emite um sinal para a câmera.
        *   `_apply_ui_scale_preset(preset_name: String)`: Ajusta a escala do `CanvasLayer` ou de elementos da UI.
*   **Justificativa:** Centralizar a aplicação de todas as configurações de vídeo e idioma no `SceneControl`, que tem acesso direto aos elementos visuais e ao `DisplayServer`.

**Passo 9: Verificação de Sincronia e Eficiência**
*   **Ação:**
    1.  Confirmar o uso de `call_deferred` nas chamadas de aplicação de configurações no `AudioManager` e `SceneControl` para evitar problemas de ordem de execução.
    2.  Realizar buscas finais para garantir a ausência de quaisquer referências ao `VideoManager` em todo o projeto.
    3.  Realizar buscas para garantir a ausência de chamadas diretas entre `SettingsManager`, `AudioManager` e `SceneControl` que não passem pelo `GlobalEvents`.
*   **Justificativa:** Garantir a integridade da arquitetura desacoplada.

**Passo 10: Atualização do `DebugConsole`**
*   **Ação:** Modificar `BodyLess\Autoloads\debug_console.gd`.
    1.  **Conexões:** Em `_connect_all_signals()`, remover quaisquer conexões a sinais individuais antigos de áudio/vídeo.
    2.  **Novas Conexões:** Garantir que esteja conectado aos novos sinais unificados: `GlobalEvents.setting_changed`, `GlobalEvents.loading_settings_changed`, `GlobalEvents.request_setting_changed`, `GlobalEvents.request_loading_settings_changed`.
    3.  **Aprimoramento de Log:** Confirmar que `_log_generic_signal` lida bem com dicionários (usando `JSON.stringify`) para os novos sinais.
*   **Justificativa:** O `DebugConsole` precisa refletir o novo sistema de sinais para depuração eficaz.

**Passo 11: Atualização do `project.godot` (Configurações de Renderização)**
*   **Ação:** Abrir `BodyLess\project.godot` e ajustar as configurações padrão de renderização para suportar a flexibilidade de resolução e FSR.
    1.  `display/window/size/viewport_width` e `viewport_height` (definir um valor base, ex: 1280x720).
    2.  `display/window/stretch/mode = "viewport"`
    3.  `display/window/stretch/aspect = "expand"` (ou `keep` para pixel art estrito).
    4.  `rendering/textures/default_texture_filter = 0` (Nearest, para pixel art).
    5.  `rendering/scaling_3d/mode = 0` (desativado por padrão, será controlado via script).
*   **Justificativa:** Definir as configurações base do projeto para o comportamento de escalonamento desejado.

--- 
**Fase 2: Implementação de Feedback Visual e Guias (4 Passos)**

**Passo 12: Planejamento do Sistema de Tooltips**
*   **Ação:**
    1.  **Criar Cena Base:** `BodyLess\Scenes\UI\Components\Tooltip.tscn`. Deve ser um `PanelContainer` com um `Label` dentro para exibir o texto.
    2.  **Criar Script:** `BodyLess\Scripts\UI\Components\Tooltip.gd`. O script deve ter uma função `show_tooltip(text, position)` que atualiza o `Label` e posiciona a cena.
    3.  **Criar Manager (Autoload):** `TooltipManager.gd`. Este manager irá instanciar e gerenciar a cena do Tooltip. Ele ouvirá sinais `GlobalEvents.show_tooltip_requested` e `GlobalEvents.hide_tooltip_requested`.
    4.  **Integrar:** Em elementos de UI (como botões de ícone no menu de configurações), usar os sinais `mouse_entered` e `mouse_exited` para emitir os sinais para o `TooltipManager`.
*   **Justificativa:** Fornecer um sistema centralizado e desacoplado para exibir dicas informativas, melhorando a clareza da interface sem poluição visual permanente.

**Passo 13: Planejamento do Sistema de Popovers**
*   **Ação:**
    1.  **Criar Cena Base:** `BodyLess\Scenes\UI\Components\Popover.tscn`. Será um `PanelContainer` mais complexo, com um `VBoxContainer` para permitir a adição de `Label`, `TextureRect`, `Button`, etc.
    2.  **Criar Manager (Autoload):** `PopoverManager.gd`. Ouvirá um sinal `GlobalEvents.show_popover_requested(content_data, parent_node)`, onde `content_data` é um dicionário descrevendo o que exibir e `parent_node` é a referência do nó que o acionou.
    3.  **Lógica de Fechamento:** O `PopoverManager` deve lidar com o fechamento do popover quando o usuário clica fora de sua área.
*   **Justificativa:** Implementar um sistema para exibir informações ricas e ações contextuais (como menus de confirmação ou detalhes de itens) de forma não-bloqueante.

**Passo 14: Planejamento do Sistema de Toasts/Snackbars**
*   **Ação:**
    1.  **Criar Cena Base:** `BodyLess\Scenes\UI\Components\Toast.tscn`. Um `PanelContainer` com um `Label` e talvez um `TextureRect` para um ícone. A cena deve ter uma `AnimationPlayer` para controlar seu aparecimento e desaparecimento (fade-in/out, slide-up/down).
    2.  **Criar Manager (Autoload):** `ToastManager.gd`. Ele gerenciará uma fila de notificações para exibi-las uma a uma. Ouvirá o sinal `GlobalEvents.show_toast_requested(message, type)`, onde `type` pode ser "info", "success", "error".
    3.  **Integração:** O `SaveSystem` emitirá um sinal de sucesso ao salvar, e outros sistemas podem emitir sinais de erro ou informação.
*   **Justificativa:** Fornecer feedback imediato e não-intrusivo para as ações do usuário, como salvar configurações ou encontrar um item.

**Passo 15: Planejamento do Sistema de Coach Marks (Tour Guiado)**
*   **Ação:**
    1.  **Criar Cena Base:** `BodyLess\Scenes\UI\Components\CoachMark.tscn`. Esta cena será mais complexa, contendo um `PanelContainer` para o texto, botões "Próximo"/"Pular", e possivelmente uma área de destaque (usando `Light2D` ou um shader para escurecer o resto da tela).
    2.  **Criar Manager (Autoload):** `TutorialManager.gd`. Este manager será responsável por orquestrar a sequência do tour. Ele lerá os passos de um `Resource` ou `JSON`.
    3.  **Lógica de Gatilho:** O `TutorialManager` ouvirá um sinal `GlobalEvents.start_tutorial_requested(tutorial_name)`. O `GlobalMachine` pode emitir este sinal na primeira vez que o jogo é iniciado.
*   **Justificativa:** Criar um sistema de onboarding para guiar novos jogadores através das funcionalidades essenciais do jogo ou de menus complexos, melhorando a curva de aprendizado.

--- 
**Fase 3: Extensão e Novas Funcionalidades (15 Passos)**

**Passo 16: Planejamento da Estrutura de Pastas para Cenas de Jogo**
*   **Ação:** Criar as seguintes pastas:
    *   `BodyLess\Scenes\Game\TopDown\`
    *   `BodyLess\Scenes\Game\Platformer\`
    *   `BodyLess\Scenes\Game\3D\`
*   **Justificativa:** Organização clara para novos conteúdos de jogo.

**Passo 17: Planejamento da Cena TopDown Playground**
*   **Ação:** Detalhar a criação da cena e seus componentes.
    *   **Cena Principal:** `TopDown_Playground.tscn` (Node2D) com `TileMap`.
    *   **Player:** `Player_TopDown.tscn` (CharacterBody2D) com `AnimatedSprite2D`, `Camera2D` (smoothing, limits).
    *   **Inimigo Base:** `Enemy_TopDown.tscn` (CharacterBody2D/StaticBody2D).
    *   **Itens:** `WeaponPickup_TopDown.tscn`, `HealingPotion_TopDown.tscn` (Area2D).
*   **Justificativa:** Fornecer um ambiente de teste funcional para mecânicas Top-Down.

**Passo 18: Planejamento da Cena Platformer Playground**
*   **Ação:** Detalhar a criação da cena e seus componentes.
    *   **Cena Principal:** `Platformer_Playground.tscn` (Node2D) com `TileMap`.
    *   **Player:** `Player_Platformer.tscn` (CharacterBody2D) com `AnimatedSprite2D`, `Camera2D` (smoothing, limits).
    *   **Inimigo Base:** `Enemy_Platformer.tscn` (CharacterBody2D/StaticBody2D).
    *   **Itens:** `WeaponPickup_Platformer.tscn`, `HealingPotion_Platformer.tscn` (Area2D).
*   **Justificativa:** Fornecer um ambiente de teste funcional para mecânicas de Plataforma.

**Passo 19: Planejamento da Cena 3D Playground**
*   **Ação:** Detalhar a criação da cena e seus componentes.
    *   **Cena Principal:** `3D_Playground.tscn` (Node3D) com `MeshInstance3D` e `StaticBody3D`.
    *   **Player:** `Player_3D.tscn` (CharacterBody3D) com `MeshInstance3D`, `Camera3D`.
    *   **Inimigo Base:** `Enemy_3D.tscn` (CharacterBody3D/StaticBody3D).
    *   **Itens:** `WeaponPickup_3D.tscn`, `HealingPotion_3D.tscn` (Area3D).
*   **Justificativa:** Fornecer um ambiente de teste funcional para mecânicas 3D.

**Passo 20: Planejamento dos Recursos de Armas e Socos (`Resource`s)**
*   **Ação:**
    *   **Script Base:** Criar `BodyLess\Resources\Scripts\WeaponData.gd` (extends Resource) com propriedades de dano, alcance, tipo, recarga, munição.
    *   **Recursos (`.tres`):** Criar `Punch.tres`, `Sword.tres`, `Bow.tres`, `Pistol.tres`, `Grenade.tres`, `MachineGun.tres` baseados em `WeaponData.gd`.
    *   **Lógica de Recarga:** Implementar no Player (ou componente de arma) com `Timer` e animação, reagindo a eventos.
*   **Justificativa:** Modularizar dados de armas para fácil criação e balanceamento.

**Passo 21: Planejamento dos Sistemas Universais (Autoloads)**
*   **Ação:** Detalhar a criação e responsabilidades dos seguintes Autoloads:
    *   **`InventoryManager`:** Gerencia inventário, emite `GlobalEvents.inventory_changed`.
    *   **`QuestSystem`:** Gerencia quests (incluindo tutorial), emite `GlobalEvents.quest_updated`.
    *   **`LootSystem`:** Gerencia drops de inimigos, usa `LootTable.gd` e `LootItem.gd` (Resources).
    *   **`FloatingTextManager`:** Instancia `FloatingText.tscn` para feedback de dano.
    *   **`SaveSystem`:** Orquestra salvamento/carregamento de dados de outros Managers.
    *   **`GlobalMachine`:** Gerencia estado global do jogo e flags de progresso.
*   **Justificativa:** Fornecer funcionalidades globais desacopladas.

**Passo 22: Planejamento da Implementação de Inimigos**
*   **Ação:**
    *   **Script Base:** Criar `BodyLess\Scripts\Enemy\enemy.gd` (extends CharacterBody2D/3D) com lógica de dano, morte, sons, texto flutuante, loot.
    *   **Recurso de Dados do Inimigo:** Criar `BodyLess\Resources\Scripts\EnemyData.gd` (extends Resource) com propriedades de saúde, dano, velocidade, comportamento (estático, patrulha, FSM).
    *   **Recursos de Dados (`.tres`):** Criar `DummyData.tres`, `PatrolBotData.tres`, `HunterData.tres`.
    *   **Máquina de Estados (FSM):** Implementar FSM genérica no `Enemy.gd` com estados `Idle`, `Patrol`, `Chase`, `Attack`.
*   **Justificativa:** Estruturar a criação de inimigos de forma modular e extensível.

**Passo 23: Planejamento da HUD Universal**
*   **Ação:**
    *   **Cena:** Criar `BodyLess\Scenes\UI\HUD.tscn` (CanvasLayer) com barra de vida (conectada a `GlobalMachine`) e hotbar (conectada a `InventoryManager`).
    *   **Script:** Criar `BodyLess\Scripts\UI\HUD.gd` para atualização visual e lógica de troca de armas.
*   **Justificativa:** Fornecer uma interface de usuário em jogo consistente e desacoplada.

**Passo 24: Planejamento da Internacionalização (I18N) e FSR**
*   **Ação:**
    *   **I18N:** Adicionar novos arquivos `.po` em `BodyLess\I18N\`. Garantir que a UI use chaves de tradução. Adicionar opção de idioma na UI de configurações.
    *   **FSR:** Pesquisar API nativa do Godot 4.x para FSR. Adicionar opções de FSR na UI de vídeo e garantir que `SceneControl` aplique a configuração via `ProjectSettings.set_setting`.
*   **Justificativa:** Suporte robusto a múltiplos idiomas e otimização de desempenho visual.

**Passo 25: Planejamento do Sistema de Spawner e Grupos**
*   **Ação:**
    *   **Cena:** Criar `BodyLess\Scenes\Game\Spawner.tscn` (Node2D/Node3D) com `Timer` para instanciar inimigos em pontos de spawn. Adicionar inimigos ao grupo "enemies".
    *   **Lógica de Limpeza:** Botão na UI de debug ou `WorldManager` (futuro) para chamar `get_tree().call_group("enemies", "queue_free")`.
*   **Justificativa:** Gerenciamento eficiente de inimigos e objetos no nível.

**Passo 26: Planejamento do Polimento e "Juice"**
*   **Ação:**
    *   **Áudio Espacial:** Configurar `AudioListener2D/3D` na câmera. Usar `AudioStreamPlayer2D/3D` para SFX posicionais.
    *   **Efeitos Visuais:** Criar `HitEffect.tscn` com `GPUParticles2D/3D` e som.
    *   **Camera Shake:** Implementar função `camera_shake` no script da câmera, chamada via sinal.
    *   **AnimationTree:** No Player, configurar `AnimationTree` com `AnimationNodeStateMachine` para gerenciar animações.
*   **Justificativa:** Melhorar a experiência do jogador com feedback visual e auditivo.

**Passo 27: Planejamento da Documentação Final e Testes**
*   **Ação:**
    *   **Atualizar Documentação Existente:** `BodyLess\Docs\Refatoracao_Configuracoes.md`.
        *   Explicitamente mencionar os 4 novos sinais (`setting_changed`, `loading_settings_changed`, `request_setting_changed`, `request_loading_settings_changed`) e seus propósitos.
        *   Discutir a remoção do `VideoManager` e a assunção de suas responsabilidades pelo `SceneControl`.
        *   Detalhar o suporte a múltiplos idiomas, incluindo a lógica de mapeamento de locale do sistema operacional.
    *   **Criar Nova Documentação:** `BodyLess\Docs\Arquitetura_Extensao.md`, `BodyLess\Docs\Playground_Design.md`, `BodyLess\Docs\Weapon_System.md`.
    *   **Definir Testes Manuais e Automatizados:** Testes abrangentes para todas as funcionalidades implementadas.
*   **Justificativa:** Garantir a manutenibilidade e a qualidade do projeto.

**Passo 28: Planejamento de Otimização de Performance**
*   **Ação:**
    *   Identificar gargalos de performance (CPU, GPU, memória).
    *   Implementar técnicas de otimização (pooling de objetos, otimização de shaders, LOD para 3D, culling).
    *   Monitorar performance com ferramentas do Godot.
*   **Justificativa:** Garantir que o jogo rode suavemente em diversas configurações de hardware.

**Passo 29: Planejamento de Acessibilidade**
*   **Ação:**
    *   Revisar opções de acessibilidade (legendas, remapeamento de controles, modos daltônicos, opções de áudio).
    *   Garantir que a UI seja navegável por teclado/controle.
*   **Justificativa:** Tornar o jogo acessível a um público mais amplo.

**Passo 30: Planejamento de Build e Distribuição**
*   **Ação:**
    *   Configurar exportação para plataformas alvo (PC, Web, Mobile).
    *   Testar builds em diferentes ambientes.
    *   Preparar assets para distribuição (ícones, splash screens).
*   **Justificativa:** Finalizar o processo de desenvolvimento para lançamento.